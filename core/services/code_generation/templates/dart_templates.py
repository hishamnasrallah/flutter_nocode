# File: core/services/code_generation/templates/dart_templates.py
"""
Reusable Dart code templates for Flutter code generation.
"""


class DartTemplates:
    """Collection of reusable Dart code templates."""

    # File headers
    FILE_HEADER = '''// Generated by Flutter App Builder
// File: {file_path}
// Generated at: {timestamp}

'''

    # Import templates
    MATERIAL_IMPORT = "import 'package:flutter/material.dart';"
    CUPERTINO_IMPORT = "import 'package:flutter/cupertino.dart';"
    HTTP_IMPORT = "import 'package:http/http.dart' as http;"
    CONVERT_IMPORT = "import 'dart:convert';"
    ASYNC_IMPORT = "import 'dart:async';"

    # Class templates
    STATELESS_WIDGET = '''class {class_name} extends StatelessWidget {{
  {properties}

  const {class_name}({{
    super.key,
    {constructor_params}
  }});

  @override
  Widget build(BuildContext context) {{
    return {widget_content};
  }}
}}'''

    STATEFUL_WIDGET = '''class {class_name} extends StatefulWidget {{
  {properties}

  const {class_name}({{
    super.key,
    {constructor_params}
  }});

  @override
  _{class_name}State createState() => _{class_name}State();
}}

class _{class_name}State extends State<{class_name}> {{
  {state_variables}

  @override
  void initState() {{
    super.initState();
    {init_code}
  }}

  @override
  void dispose() {{
    {dispose_code}
    super.dispose();
  }}

  @override
  Widget build(BuildContext context) {{
    return {widget_content};
  }}
}}'''

    # Method templates
    ASYNC_METHOD = '''Future<{return_type}> {method_name}({params}) async {{
  try {{
    {method_body}
  }} catch (e) {{
    {error_handling}
  }}
}}'''

    BUILD_METHOD = '''@override
Widget build(BuildContext context) {{
  return {widget_content};
}}'''

    # Navigation templates
    PUSH_NAMED = "Navigator.pushNamed(context, '{route_name}');"
    PUSH_REPLACEMENT = "Navigator.pushReplacementNamed(context, '{route_name}');"
    POP = "Navigator.pop(context);"
    POP_WITH_RESULT = "Navigator.pop(context, {result});"

    # Dialog templates
    ALERT_DIALOG = '''showDialog(
  context: context,
  builder: (BuildContext context) {{
    return AlertDialog(
      title: Text('{title}'),
      content: Text('{message}'),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text('Cancel'),
        ),
        TextButton(
          onPressed: () {{
            {on_confirm}
            Navigator.pop(context);
          }},
          child: Text('OK'),
        ),
      ],
    );
  }},
);'''

    SNACKBAR = '''ScaffoldMessenger.of(context).showSnackBar(
  SnackBar(
    content: Text('{message}'),
    duration: Duration(seconds: {duration}),
    action: SnackBarAction(
      label: '{action_label}',
      onPressed: () {{
        {action_code}
      }},
    ),
  ),
);'''

    # Form templates
    FORM_FIELD = '''TextFormField(
  controller: {controller_name},
  decoration: InputDecoration(
    labelText: '{label}',
    hintText: '{hint}',
    prefixIcon: Icon({icon}),
    border: OutlineInputBorder(),
  ),
  validator: (value) {{
    {validation_code}
  }},
  onSaved: (value) {{
    {save_code}
  }},
)'''

    # API call templates
    HTTP_GET = '''final response = await http.get(
  Uri.parse('{url}'),
  headers: {headers},
);

if (response.statusCode == 200) {{
  {success_code}
}} else {{
  {error_code}
}}'''

    HTTP_POST = '''final response = await http.post(
  Uri.parse('{url}'),
  headers: {headers},
  body: jsonEncode({body}),
);

if (response.statusCode == {expected_status}) {{
  {success_code}
}} else {{
  {error_code}
}}'''

    # State management templates
    SET_STATE = '''setState(() {{
  {state_updates}
}});'''

    # List/Grid item templates
    LIST_TILE_TEMPLATE = '''ListTile(
  leading: {leading_widget},
  title: Text('{title}'),
  subtitle: Text('{subtitle}'),
  trailing: {trailing_widget},
  onTap: () {{
    {on_tap_code}
  }},
)'''

    GRID_ITEM_TEMPLATE = '''Card(
  elevation: {elevation},
  child: InkWell(
    onTap: () {{
      {on_tap_code}
    }},
    child: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        {icon_or_image},
        SizedBox(height: 8),
        Text(
          '{title}',
          style: TextStyle(fontSize: {font_size}),
          textAlign: TextAlign.center,
        ),
      ],
    ),
  ),
)'''

    # Error handling templates
    TRY_CATCH = '''try {{
  {try_code}
}} catch (e) {{
  {catch_code}
}} finally {{
  {finally_code}
}}'''

    ERROR_WIDGET = '''Center(
  child: Column(
    mainAxisAlignment: MainAxisAlignment.center,
    children: [
      Icon(Icons.error_outline, size: 64, color: Colors.red),
      SizedBox(height: 16),
      Text(
        '{error_message}',
        style: TextStyle(fontSize: 16),
        textAlign: TextAlign.center,
      ),
      SizedBox(height: 16),
      ElevatedButton(
        onPressed: () {{
          {retry_code}
        }},
        child: Text('Retry'),
      ),
    ],
  ),
)'''

    LOADING_WIDGET = '''Center(
  child: Column(
    mainAxisAlignment: MainAxisAlignment.center,
    children: [
      CircularProgressIndicator(),
      SizedBox(height: 16),
      Text('{loading_message}'),
    ],
  ),
)'''

    # Animation templates
    ANIMATED_CONTAINER = '''AnimatedContainer(
  duration: Duration(milliseconds: {duration}),
  curve: Curves.{curve},
  width: {width},
  height: {height},
  decoration: BoxDecoration(
    color: {color},
    borderRadius: BorderRadius.circular({radius}),
  ),
  child: {child},
)'''

    # Shared Preferences templates
    SAVE_PREF = '''final prefs = await SharedPreferences.getInstance();
await prefs.set{type}('{key}', {value});'''

    LOAD_PREF = '''final prefs = await SharedPreferences.getInstance();
final {variable_name} = prefs.get{type}('{key}') ?? {default_value};'''

    @classmethod
    def format_template(cls, template: str, **kwargs) -> str:
        """
        Format a template with provided values.

        Args:
            template: Template string to format
            **kwargs: Values to substitute in template

        Returns:
            str: Formatted template
        """
        try:
            return template.format(**kwargs)
        except KeyError as e:
            raise ValueError(f"Missing required template parameter: {e}")

    @classmethod
    def get_import_statements(cls, imports: list) -> str:
        """
        Generate import statements from a list of import types.

        Args:
            imports: List of import types

        Returns:
            str: Formatted import statements
        """
        import_map = {
            'material': cls.MATERIAL_IMPORT,
            'cupertino': cls.CUPERTINO_IMPORT,
            'http': cls.HTTP_IMPORT,
            'convert': cls.CONVERT_IMPORT,
            'async': cls.ASYNC_IMPORT,
        }

        statements = []
        for import_type in imports:
            if import_type in import_map:
                statements.append(import_map[import_type])
            else:
                # Assume it's a custom import path
                statements.append(f"import '{import_type}';")

        return '\n'.join(statements)

    @classmethod
    def create_stateless_widget(cls, class_name: str, widget_content: str,
                                properties: dict = None, constructor_params: dict = None) -> str:
        """
        Create a stateless widget from template.

        Args:
            class_name: Name of the widget class
            widget_content: Build method content
            properties: Class properties
            constructor_params: Constructor parameters

        Returns:
            str: Complete stateless widget code
        """
        props = []
        if properties:
            for name, type_str in properties.items():
                props.append(f"final {type_str} {name};")

        params = []
        if constructor_params:
            for name, required in constructor_params.items():
                if required:
                    params.append(f"required this.{name}")
                else:
                    params.append(f"this.{name}")

        return cls.format_template(
            cls.STATELESS_WIDGET,
            class_name=class_name,
            properties='\n  '.join(props) if props else '',
            constructor_params=',\n    '.join(params) if params else '',
            widget_content=widget_content
        )

    @classmethod
    def create_stateful_widget(cls, class_name: str, widget_content: str,
                               state_variables: dict = None, init_code: str = '',
                               dispose_code: str = '', properties: dict = None) -> str:
        """
        Create a stateful widget from template.

        Args:
            class_name: Name of the widget class
            widget_content: Build method content
            state_variables: State class variables
            init_code: initState method code
            dispose_code: dispose method code
            properties: Widget class properties

        Returns:
            str: Complete stateful widget code
        """
        props = []
        if properties:
            for name, type_str in properties.items():
                props.append(f"final {type_str} {name};")

        state_vars = []
        if state_variables:
            for name, definition in state_variables.items():
                state_vars.append(definition)

        return cls.format_template(
            cls.STATEFUL_WIDGET,
            class_name=class_name,
            properties='\n  '.join(props) if props else '',
            constructor_params='',
            state_variables='\n  '.join(state_vars) if state_vars else '',
            init_code=init_code or '// Initialize state',
            dispose_code=dispose_code or '// Dispose resources',
            widget_content=widget_content
        )